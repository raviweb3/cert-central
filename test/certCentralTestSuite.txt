import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { expect } from "chai";
import { ethers } from "hardhat";

describe("Admin", function () {
  async function deployCertContractsFixture() {
    // Contracts are deployed using the first signer/account by default
    console.log(await (await ethers.getSigners()).length);
    const [ownerAcc, verifier1Acc, verifier2Acc, certifier1Acc, certifier2Acc, profile1Acc, profile2Acc, profile3Acc ] = await ethers.getSigners();

    const CertifierNFT = await ethers.getContractFactory("CertifierNFT");
    const ProfileNFT = await ethers.getContractFactory("ProfileNFT");
    const CertificateNFT = await ethers.getContractFactory("CertificateNFT");
    const CertDatabase = await ethers.getContractFactory("CertDatabase");
    const CertCommon = await ethers.getContractFactory("CertCommon");
    const CertAdmin = await ethers.getContractFactory("CertAdmin");
    const Certifier = await ethers.getContractFactory("Certifier");
    const Profile = await ethers.getContractFactory("Profile");

    const certifierNFT = await CertifierNFT.deploy();
    const profileNFT = await ProfileNFT.deploy();
    const certificateNFT = await CertificateNFT.deploy();
    const certDatabase = await CertDatabase.deploy();
    const certCommon = await CertCommon.deploy(certDatabase.address);
    const certAdmin = await CertAdmin.deploy(certDatabase.address,certCommon.address,certifierNFT.address);
    const certifier = await Certifier.deploy(certDatabase.address,certCommon.address,profileNFT.address,certificateNFT.address);
    const profile = await Profile.deploy(certDatabase.address,certCommon.address);

    return { ownerAcc, verifier1Acc, verifier2Acc, certifier1Acc, certifier2Acc, profile1Acc, profile2Acc, profile3Acc, certifierNFT, certificateNFT, certDatabase, certCommon, certAdmin, certifier, profile };
  }

  describe("Deployment", function () {
   it("Should deploy contract suite", async function () {
      const { ownerAcc,verifier1Acc, certAdmin } = await loadFixture(deployCertContractsFixture);
      await certAdmin.connect(ownerAcc);
      console.log(verifier1Acc.address);
      await certAdmin.enableAsVerifier(verifier1Acc.address);
      console.log(await certAdmin.isVerifierRole(verifier1Acc.address));
    });

    it("Should be able to register as ceritifer", async function () {
      const { ownerAcc, certifier1Acc, certifier  } = await loadFixture(deployCertContractsFixture);
      await certifier.connect(certifier1Acc).registerCertifier("ABC Labs","Training","www.abclabs.com","ipfsDetailsUri");
     });

    it("Should Not be able to add a Course before KYC Verification", async function () {
      const { ownerAcc, certifier1Acc, certifier  } = await loadFixture(deployCertContractsFixture);
      await expect(certifier.connect(certifier1Acc).registerCourse("Blockchain training","complete training","www.abclabs.com/blockchain",
                                     ['Solidity','Javascript'],0,0,0)).to.be.revertedWith(
                                      "You must be a verified certifier"
                                    );
     
    });

    it("Should be able to verify the ceritifer and add course", async function () {
      const { ownerAcc, verifier1Acc, certifier1Acc, certAdmin, certifier } = await loadFixture(deployCertContractsFixture);
      await certAdmin.connect(ownerAcc);
      await certAdmin.enableAsVerifier(verifier1Acc.address);
      (await certAdmin.isVerifierRole(verifier1Acc.address));
      await certifier.connect(certifier1Acc).registerCertifier("ABC Labs","Training","www.abclabs.com","ipfsDetailsUri");
      (await certAdmin.connect(verifier1Acc).verifyCertifier(certifier1Acc.address));
      certifier.connect(certifier1Acc).registerCourse("Blockchain training","complete training","www.abclabs.com/blockchain",
                                     ['Solidity','Javascript'],0,0,0);   
        
      const courses = await certifier.connect(certifier1Acc).getCourses(certifier1Acc.address);
      expect(courses[0].name).to.be.equals("Blockchain training"); 
      expect(courses[0].status).to.be.equals(0);                                
     });


     it("Should be able to Enroll a profile", async function () {
      const { ownerAcc, verifier1Acc, certifier1Acc, certAdmin, certifier, profile1Acc, profile } = await loadFixture(deployCertContractsFixture);
      
      await certAdmin.connect(ownerAcc);
      await certAdmin.enableAsVerifier(verifier1Acc.address);
      (await certAdmin.isVerifierRole(verifier1Acc.address));
      await certifier.connect(certifier1Acc).registerCertifier("ABC Labs","Training","www.abclabs.com","ipfsDetailsUri");
      (await certAdmin.connect(verifier1Acc).verifyCertifier(certifier1Acc.address));
      await certifier.connect(certifier1Acc).registerCourse("Blockchain training","complete training","www.abclabs.com/blockchain",
      ['Solidity','Javascript'],0,0,0);  

      const courses = await certifier.connect(certifier1Acc).getCourses(certifier1Acc.address);
      console.log(courses);

      // string memory _name, string memory _email,string memory _detailsUri
      await profile.connect(profile1Acc).registerProfile("ravi kiran", "test@gmail.com", "www.linkedin.com/ravikiran");
      const newProfile = await profile.connect(profile1Acc).getProfile(profile1Acc.address);
      console.log(newProfile);
      console.log("new profile ----")
      await certifier.connect(certifier1Acc).enrollProfile(0,profile1Acc.address);
      const enrollments = await certifier.getEnrollments(0);
      console.log(enrollments);
      expect(await enrollments[0].profile).to.be.equals(profile1Acc.address); 

      //issue certificate fails (Course is still ongoing)
      await expect(certifier.connect(certifier1Acc).issueCourseNFT(profile1Acc.address, 0,"www.nft.com")).to.be.revertedWith(
        "Course is still ongoing"
      );
     });

     it("Should be able to Enroll & Kyc a profile", async function () {
      const { ownerAcc, verifier1Acc, certifier1Acc, certAdmin, certifier, profile1Acc, profile } = await loadFixture(deployCertContractsFixture);
      
      await certAdmin.connect(ownerAcc);
      await certAdmin.enableAsVerifier(verifier1Acc.address);
      (await certAdmin.isVerifierRole(verifier1Acc.address));
      await certifier.connect(certifier1Acc).registerCertifier("ABC Labs","Training","www.abclabs.com","ipfsDetailsUri");
      (await certAdmin.connect(verifier1Acc).verifyCertifier(certifier1Acc.address));
      await certifier.connect(certifier1Acc).registerCourse("Blockchain training","complete training","www.abclabs.com/blockchain",
      ['Solidity','Javascript'],0,0,0);  

      const courses = await certifier.connect(certifier1Acc).getCourses(certifier1Acc.address);
      console.log(courses);

      // string memory _name, string memory _email,string memory _detailsUri
      await profile.connect(profile1Acc).registerProfile("ravi kiran", "test@gmail.com", "www.linkedin.com/ravikiran");
      const newProfile = await profile.connect(profile1Acc).getProfile(profile1Acc.address);
      console.log(newProfile);
      console.log("new profile ----")
      await certifier.connect(certifier1Acc).enrollProfile(0,profile1Acc.address);
      const enrollments = await certifier.getEnrollments(0);
      console.log(enrollments);
      expect(await enrollments[0].profile).to.be.equals(profile1Acc.address); 

      await certifier.connect(certifier1Acc).updateCourseStatus(0,3);

      //issue certificate fails (Course is still ongoing)
      await certifier.connect(certifier1Acc).issueCourseNFT(profile1Acc.address, 0,"www.nft.com");
      await certifier.connect(certifier1Acc).issueProfileNFT(profile1Acc.address, "www.nft2.com");
      await certAdmin.connect(ownerAcc).issueCertifierNFT(certifier1Acc.address, "www.nft2.com");  
     });
  });
});
